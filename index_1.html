<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多功能速写板</title>
</head>
<body>
    <h1>多功能速写板</h1>
    
    <!-- 画布 -->
    <canvas id="sketchCanvas" width="800" height="600" style="border:1px solid #000; background:#fff;"></canvas>
    
    <!-- 控制区域（新增橡皮工具和橡皮大小调整） -->
    <div>
        <!-- 工具选择（新增橡皮工具） -->
        <button onclick="setTool('pen')" class="tool-btn" style="background:#e0e0e0;">画笔</button>
        <button onclick="setTool('eraser')" class="tool-btn">橡皮</button> <!-- 新增橡皮工具 -->
        <button onclick="setTool('line')" class="tool-btn">直线</button>
        <button onclick="setTool('arrow')" class="tool-btn">箭头</button>
        <button onclick="setTool('rect')" class="tool-btn">矩形</button>
        <button onclick="setTool('circle')" class="tool-btn">圆形</button>
        <button onclick="setTool('ellipse')" class="tool-btn">椭圆</button>
        <button onclick="setTool('triangle')" class="tool-btn">固定三角形</button>
        <button onclick="setTool('irregularTriangle')" class="tool-btn">不规则三角形</button>
        <button onclick="setTool('quadrilateral')" class="tool-btn">不规则四边形</button>
        <button onclick="setTool('pentagon')" class="tool-btn">不规则五边形</button>
        <button onclick="setTool('hexagon')" class="tool-btn">不规则六边形</button>
        <button onclick="setTool('text')" class="tool-btn">文字</button>
        
        <!-- 参数控制（新增橡皮大小调整） -->
        <label for="lineWidth">粗细/橡皮大小：</label>
        <input type="number" id="lineWidth" value="2" min="1" max="50">px <!-- 最大调整到50px，适合擦除 -->
        
        <label for="colorPicker" style="margin-left:10px;">颜色：</label>
        <input type="color" id="colorPicker" value="#000000">
        
        <label for="fontSize" style="margin-left:10px;">文字大小：</label>
        <input type="number" id="fontSize" value="16" min="8" max="48">px
        
        <button onclick="clearCanvas()">清除画布</button>
        <button onclick="downloadCanvasAsPNG()">下载PNG</button>
        <span style="margin-left:10px; font-size:14px;">文字输入：Alt+U 确认 | 多边形：点击设顶点，右键/双击结束</span>
    </div>

    <!-- 多行文本输入域 -->
    <textarea id="textInput" style="display:none; position:absolute; z-index:10; border:1px solid #666; padding:4px; background:#fff; resize:both;" placeholder="输入多行文字后，按 Alt+U 确认"></textarea>

    <script>
        const canvas = document.getElementById('sketchCanvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('textInput');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pen';
        let tempCanvasData = null;
        let textStartX = 0;
        let textStartY = 0;
        
        // 多边形相关变量
        let polygonVertices = [];
        let isPolygonDrawing = false;

        // 工具配置
        const polygonConfig = {
            irregularTriangle: 3,
            quadrilateral: 4,
            pentagon: 5,
            hexagon: 6
        };

        // 获取DOM元素
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthInput = document.getElementById('lineWidth');

        // 设置当前工具
        function setTool(tool) {
            currentTool = tool;
            textInput.style.display = 'none';
            resetPolygonState();
            // 重置按钮样式
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.style.background = 'none';
            });
            // 高亮当前工具按钮
            event.target.style.background = '#e0e0e0';
            // 调整输入框提示文字（区分画笔/橡皮）
            document.querySelector('label[for="lineWidth"]').textContent = 
                currentTool === 'eraser' ? '橡皮大小：' : '粗细/橡皮大小：';
        }

        // 重置多边形状态
        function resetPolygonState() {
            isPolygonDrawing = false;
            polygonVertices = [];
        }

        // 鼠标按下事件
        canvas.addEventListener('mousedown', (e) => {
            const [x, y] = getCanvasCoordinates(e);
            
            // 文字工具
            if (currentTool === 'text') {
                textStartX = x;
                textStartY = y;
                showTextInput(x, y);
                return;
            }

            // 多边形工具
            if (polygonConfig[currentTool]) {
                handlePolygonMouseDown(x, y);
                return;
            }

            // 橡皮工具
            if (currentTool === 'eraser') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
                // 橡皮配置：圆形笔触、透明擦除（合成模式为清除）
                ctx.lineWidth = lineWidthInput.value;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = 'destination-out'; // 清除模式：绘制内容会擦除原有像素
                ctx.strokeStyle = 'rgba(0,0,0,1)'; // 颜色不影响，关键是合成模式
                return;
            }

            // 其他绘制工具
            isDrawing = true;
            [lastX, lastY] = [x, y];
            if (currentTool !== 'pen') {
                tempCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                ctx.lineWidth = lineWidthInput.value;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = colorPicker.value;
                ctx.globalCompositeOperation = 'source-over'; // 恢复正常绘制模式
            }
        });

        // 鼠标移动事件
        canvas.addEventListener('mousemove', draw);

        // 鼠标抬起事件
        canvas.addEventListener('mouseup', () => {
            if (!polygonConfig[currentTool]) {
                isDrawing = false;
                tempCanvasData = null;
                // 恢复正常合成模式（避免影响后续绘制）
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
        });

        // 鼠标离开事件
        canvas.addEventListener('mouseout', () => {
            if (!polygonConfig[currentTool]) {
                isDrawing = false;
                tempCanvasData = null;
                // 恢复正常合成模式
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
        });

        // 右键事件（结束多边形）
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (polygonConfig[currentTool] && isPolygonDrawing && polygonVertices.length >= 3) {
                finishPolygonDrawing();
            }
        });

        // 双击事件（结束多边形）
        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (polygonConfig[currentTool] && isPolygonDrawing && polygonVertices.length >= 3) {
                finishPolygonDrawing();
            }
        });

        // 处理多边形鼠标按下
        function handlePolygonMouseDown(x, y) {
            const requiredVertices = polygonConfig[currentTool];
            
            if (!isPolygonDrawing) {
                isDrawing = false; // 多边形绘制时禁用其他绘制
                isPolygonDrawing = true;
                tempCanvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                polygonVertices.push([x, y]);
            } else {
                polygonVertices.push([x, y]);
                if (polygonVertices.length === requiredVertices) {
                    finishPolygonDrawing();
                }
            }
        }

        // 结束多边形绘制
        function finishPolygonDrawing() {
            const lineWidth = lineWidthInput.value;
            ctx.putImageData(tempCanvasData, 0, 0);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = colorPicker.value;
            ctx.fillStyle = 'transparent';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'source-over'; // 确保多边形绘制为正常模式

            ctx.beginPath();
            ctx.moveTo(polygonVertices[0][0], polygonVertices[0][1]);
            for (let i = 1; i < polygonVertices.length; i++) {
                ctx.lineTo(polygonVertices[i][0], polygonVertices[i][1]);
            }
            ctx.closePath();
            ctx.stroke();

            resetPolygonState();
        }

        // 核心绘制函数（新增橡皮绘制逻辑）
        function draw(e) {
            if (!isDrawing && !isPolygonDrawing) return;
            
            const [x, y] = getCanvasCoordinates(e);
            const lineWidth = lineWidthInput.value;
            const currentColor = colorPicker.value;

            // 橡皮工具绘制（擦除）
            if (currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                [lastX, lastY] = [x, y];
                return;
            }

            // 多边形预览
            if (polygonConfig[currentTool] && isPolygonDrawing) {
                drawPolygonPreview(x, y, currentColor);
                return;
            }

            // 其他基础工具绘制
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = 'transparent';
            ctx.globalCompositeOperation = 'source-over'; // 确保正常绘制模式

            switch (currentTool) {
                case 'pen':
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    [lastX, lastY] = [x, y];
                    break;
                case 'line':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    break;
                case 'arrow':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    drawArrow(lastX, lastY, x, y, lineWidth, currentColor);
                    break;
                case 'rect':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    ctx.beginPath();
                    ctx.rect(
                        Math.min(lastX, x),
                        Math.min(lastY, y),
                        Math.abs(x - lastX),
                        Math.abs(y - lastY)
                    );
                    ctx.stroke();
                    break;
                case 'circle':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    const centerX = (lastX + x) / 2;
                    const centerY = (lastY + y) / 2;
                    const radius = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2)) / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'ellipse':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    const ellipseCenterX = (lastX + x) / 2;
                    const ellipseCenterY = (lastY + y) / 2;
                    const radiusX = Math.abs(x - lastX) / 2;
                    const radiusY = Math.abs(y - lastY) / 2;
                    ctx.beginPath();
                    ctx.ellipse(ellipseCenterX, ellipseCenterY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'triangle':
                    ctx.putImageData(tempCanvasData, 0, 0);
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    const midX = (lastX + x) / 2;
                    const midY = (lastY + y) / 2;
                    const thirdX = midX - (y - lastY) * 0.5;
                    const thirdY = midY + (x - lastX) * 0.5;
                    ctx.lineTo(thirdX, thirdY);
                    ctx.closePath();
                    ctx.stroke();
                    break;
            }
        }

        // 多边形预览
        function drawPolygonPreview(currentX, currentY, color) {
            ctx.putImageData(tempCanvasData, 0, 0);
            const lineWidth = lineWidthInput.value;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = color;
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'source-over';

            if (polygonVertices.length === 1) {
                ctx.beginPath();
                ctx.arc(polygonVertices[0][0], polygonVertices[0][1], lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.fillStyle = 'transparent';
            } else {
                ctx.beginPath();
                ctx.moveTo(polygonVertices[0][0], polygonVertices[0][1]);
                for (let i = 1; i < polygonVertices.length; i++) {
                    ctx.lineTo(polygonVertices[i][0], polygonVertices[i][1]);
                }
                ctx.lineTo(currentX, currentY);
                ctx.stroke();

                polygonVertices.forEach(([vx, vy]) => {
                    ctx.beginPath();
                    ctx.arc(vx, vy, lineWidth / 2, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.fillStyle = 'transparent';
                });
            }
        }

        // 显示文本输入域
        function showTextInput(x, y) {
            const canvasRect = canvas.getBoundingClientRect();
            textInput.style.left = `${Math.min(canvasRect.left + x, window.innerWidth - 200)}px`;
            textInput.style.top = `${Math.min(canvasRect.top + y, window.innerHeight - 150)}px`;
            textInput.style.display = 'block';
            textInput.style.width = '200px';
            textInput.style.height = '100px';
            textInput.value = '';
            textInput.focus();
        }

        // 文本输入确认
        textInput.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === 'u') {
                e.preventDefault();
                const text = textInput.value.trim();
                if (text) {
                    drawMultiLineText(textStartX, textStartY, text, colorPicker.value);
                }
                textInput.style.display = 'none';
            }
        });

        // 绘制多行文字
        function drawMultiLineText(x, y, text, color) {
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const lineHeight = fontSize * 1.4;
            const lines = text.split('\n');

            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = color;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.globalCompositeOperation = 'source-over';

            lines.forEach((line, index) => {
                const lineY = y + (index * lineHeight);
                ctx.fillText(line, x, lineY);
            });
        }

        // 绘制箭头
        function drawArrow(fromX, fromY, toX, toY, lineWidth, color) {
            const headLength = lineWidth * 3;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }

        // 获取画布坐标
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }

        // 清除画布
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            textInput.style.display = 'none';
            resetPolygonState();
            ctx.globalCompositeOperation = 'source-over'; // 恢复正常模式
        }

        // 下载画布为PNG
        function downloadCanvasAsPNG() {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[-:\.T]/g, '').slice(0, 14);
            link.download = `速写板作品_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>
